#!/usr/bin/env python3
import io, os, sys, shutil

FN = "l2s_overlays.py"
BAK = FN + ".bak"

PROCESS_FUNC = r'''
def process_overlays_queue(queue_path: str, dry_run: bool = False, parallel: int = 1, keep_temp: bool = False):
    if not os.path.isfile(queue_path):
        raise FileNotFoundError(queue_path)
    with open(queue_path, "r", encoding="utf-8") as f:
        payload = json.load(f)
    entries = payload.get("entries", [])
    recipe_path = payload.get("recipe")
    print(f"[INFO] Processing overlay queue from recipe: {recipe_path}, entries={len(entries)}")

    # --- persistent promotion: ensure runner sees overlays generated by the GUI ---
    # Promote main_text or overlay_instructions.overlay_text to top-level overlay_text
    for entry in entries:
        if not entry.get("overlay_text"):
            if entry.get("main_text"):
                entry["overlay_text"] = entry["main_text"]
            else:
                oi = entry.get("overlay_instructions") or {}
                oi_ot = oi.get("overlay_text")
                if oi_ot:
                    entry["overlay_text"] = oi_ot
    # --- end promotion ---

    failures = []
    # worker wrapper
    def _worker(rec):
        out_path = rec.get("out_path")
        try:
            if not out_path or not os.path.isfile(out_path):
                return (out_path, "missing file")
            instr = rec.get("overlay_instructions", {}) or {}
            # ensure any promoted top-level overlay_text is visible inside instructions
            if rec.get("overlay_text"):
                # create a shallow copy so we don't mutate original structure unexpectedly
                instr = dict(instr)
                instr["overlay_text"] = rec.get("overlay_text")
            srt = rec.get("srt_for_clip", [])
            main_text = rec.get("main_text")
            # --- DEBUG: dump instruction shape so we can see why no overlays are applied ---
            try:
                # print a compact summary and the first overlay entry (if present)
                ot = instr.get("overlay_text")
                ot_summary = f"type={type(ot).__name__}, len={len(ot) if ot is not None and hasattr(ot,'__len__') else 'N/A'}"
                print(f"[DEBUG] apply_overlays_to_clip will receive instr keys: {list(instr.keys())}, overlay_text_summary: {ot_summary}")
                if ot and isinstance(ot, (list, tuple)) and len(ot) > 0:
                    # print the first overlay entry (safe truncate)
                    import json as _json
                    first = ot[0]
                    s = _json.dumps(first, ensure_ascii=False)
                    print(f"[DEBUG] overlay_text[0]: {s[:2000]}")
            except Exception:
                print("[DEBUG] failed to serialize overlay_text for debug")
            # --- end DEBUG ---

            if dry_run:
                return (out_path, "dry-run")
            apply_overlays_to_clip(out_path, instr, srt, main_text=main_text, prefer_pillow=True, keep_temp=keep_temp)
            return (out_path, None)
        except Exception as ex:
            return (out_path, str(ex))
    if parallel and parallel > 1:
        pool = multiprocessing.Pool(processes=parallel)
        results = pool.map(_worker, entries)
        pool.close(); pool.join()
        for out_path, err in results:
            if err:
                failures.append({"out_path": out_path, "reason": err})
    else:
        for rec in entries:
            out_path, err = _worker(rec)
            if err:
                failures.append({"out_path": out_path, "reason": err})
    print(f"[INFO] Overlay processing finished. failures={len(failures)}")
    if failures:
        for f in failures:
            _log(f"overlay failure: {f}")
    return failures
'''

def main():
    if not os.path.isfile(FN):
        print("ERROR: file not found:", FN)
        sys.exit(1)
    src = open(FN, "r", encoding="utf-8").read()
    if "def process_overlays_queue" in src:
        print("process_overlays_queue already present; no changes made.")
        return
    marker = "# ---------------- CLI ----------------"
    idx = src.find(marker)
    if idx == -1:
        print("ERROR: CLI marker not found; cannot insert function safely.")
        sys.exit(2)
    # Backup
    shutil.copy2(FN, BAK)
    print(f"Backup written: {BAK}")
    # Insert before marker
    new_src = src[:idx] + PROCESS_FUNC + "\n\n" + src[idx:]
    with open(FN, "w", encoding="utf-8") as f:
        f.write(new_src)
    print("Inserted process_overlays_queue and updated", FN)

if __name__ == "__main__":
    main()